//
//  MediaStore.swift
//  CYBMediaHolder
//
//  Mutable storage for analysis results, cache, and user annotations.
//  Thread-safe via actor isolation.
//

import Foundation

/// Cache validity information.
public struct CacheValidity: Codable, Sendable {

    /// Default max age for time-based cache validity (30 days).
    public static let defaultMaxAge: TimeInterval = 30 * 24 * 60 * 60

    /// When the cache was generated.
    public let generatedAt: Date

    /// Version of the generator.
    public let version: String

    /// Backend used to generate.
    public let sourceBackend: String

    /// Hash of source file (for invalidation).
    public let sourceHash: String?

    /// Whether this cache is still valid (time-based only).
    ///
    /// For hash-based validation, use `isValid(withCurrentHash:)` instead.
    public var isValid: Bool {
        isValid(maxAge: Self.defaultMaxAge)
    }

    /// Whether this cache is valid with a custom max age.
    ///
    /// - Parameter maxAge: Maximum age in seconds.
    /// - Returns: True if the cache is within the age limit.
    public func isValid(maxAge: TimeInterval) -> Bool {
        Date().timeIntervalSince(generatedAt) < maxAge
    }

    /// Whether this cache is valid, optionally checking source hash.
    ///
    /// If a current hash is provided and this cache has a source hash,
    /// hash comparison takes precedence over time-based expiration.
    /// This allows caches to remain valid indefinitely if the source
    /// file hasn't changed.
    ///
    /// - Parameter currentHash: The current hash of the source file, if available.
    /// - Returns: True if the cache is valid.
    ///
    /// ## Validation Logic
    /// 1. If both hashes are available and match → always valid
    /// 2. If both hashes are available but don't match → always invalid
    /// 3. If either hash is missing → fall back to time-based validation
    public func isValid(withCurrentHash currentHash: String?) -> Bool {
        // If both hashes are available, compare them
        if let cachedHash = sourceHash, let currentHash = currentHash {
            return cachedHash == currentHash
        }

        // Fall back to time-based validation
        return isValid
    }

    /// Whether this cache was generated by a compatible version.
    ///
    /// - Parameter requiredVersion: The minimum required version.
    /// - Returns: True if the cache version is compatible.
    public func isCompatible(withVersion requiredVersion: String) -> Bool {
        // Simple semantic version comparison (major.minor)
        // Could be extended for full semver support
        version >= requiredVersion
    }

    public init(
        version: String,
        sourceBackend: String,
        sourceHash: String? = nil
    ) {
        self.generatedAt = Date()
        self.version = version
        self.sourceBackend = sourceBackend
        self.sourceHash = sourceHash
    }
}

/// User-defined annotations and markers.
///
/// ## Future Extensions
/// - In/out points
/// - Named markers
/// - Notes and comments
/// - Tags and categories
public struct UserAnnotations: Codable, Sendable {
    /// User-defined tags.
    public var tags: [String]

    /// User notes/comments.
    public var notes: String?

    /// Custom markers (time -> label).
    public var markers: [Double: String]

    /// In point (seconds).
    public var inPoint: Double?

    /// Out point (seconds).
    public var outPoint: Double?

    /// Rating (1-5).
    public var rating: Int?

    public init(
        tags: [String] = [],
        notes: String? = nil,
        markers: [Double: String] = [:],
        inPoint: Double? = nil,
        outPoint: Double? = nil,
        rating: Int? = nil
    ) {
        self.tags = tags
        self.notes = notes
        self.markers = markers
        self.inPoint = inPoint
        self.outPoint = outPoint
        self.rating = rating
    }

    /// Empty annotations.
    public static let empty = UserAnnotations()
}

/// Actor-isolated mutable store for a media item.
///
/// `MediaStore` holds all mutable data associated with a media:
/// - Analysis results (waveform, peak, keyframe index)
/// - Cache state
/// - User annotations
///
/// ## Design Notes
/// - Actor isolation ensures thread safety
/// - All mutations are async
/// - Supports incremental updates (e.g., partial waveform)
///
/// ## Future Extensions
/// - Persistence to disk
/// - Sync with external systems (MAM, cloud)
/// - Undo/redo for annotations
public actor MediaStore {

    /// Analysis results.
    private var analysis: AnalysisState

    /// Cache validity information per analysis type.
    private var cacheValidity: [String: CacheValidity]

    /// User annotations.
    private var annotations: UserAnnotations

    /// Pending analysis tasks.
    private var pendingTasks: Set<String>

    /// Creates an empty media store.
    public init() {
        self.analysis = AnalysisState()
        self.cacheValidity = [:]
        self.annotations = UserAnnotations.empty
        self.pendingTasks = []
    }

    /// Creates a media store with existing state (for deserialization).
    public init(
        analysis: AnalysisState,
        cacheValidity: [String: CacheValidity] = [:],
        annotations: UserAnnotations = .empty
    ) {
        self.analysis = analysis
        self.cacheValidity = cacheValidity
        self.annotations = annotations
        self.pendingTasks = []
    }

    // MARK: - Analysis State Access

    /// Current analysis state.
    public var analysisState: AnalysisState {
        analysis
    }

    /// Whether waveform is available.
    public var hasWaveform: Bool {
        analysis.waveform != nil
    }

    /// Whether peak data is available.
    public var hasPeak: Bool {
        analysis.peak != nil
    }

    /// Whether keyframe index is available.
    public var hasKeyframeIndex: Bool {
        analysis.keyframeIndex != nil
    }

    /// Whether thumbnail index is available.
    public var hasThumbnailIndex: Bool {
        analysis.thumbnailIndex != nil
    }

    // MARK: - Analysis State Mutation

    /// Sets waveform data.
    public func setWaveform(_ waveform: WaveformData, validity: CacheValidity) {
        analysis.waveform = waveform
        cacheValidity["waveform"] = validity
    }

    /// Sets peak data.
    public func setPeak(_ peak: PeakData, validity: CacheValidity) {
        analysis.peak = peak
        cacheValidity["peak"] = validity
    }

    /// Sets keyframe index.
    public func setKeyframeIndex(_ index: KeyframeIndex, validity: CacheValidity) {
        analysis.keyframeIndex = index
        cacheValidity["keyframeIndex"] = validity
    }

    /// Sets thumbnail index.
    public func setThumbnailIndex(_ index: ThumbnailIndex, validity: CacheValidity) {
        analysis.thumbnailIndex = index
        cacheValidity["thumbnailIndex"] = validity
    }

    /// Clears a specific analysis.
    public func clearAnalysis(_ type: AnalysisType) {
        switch type {
        case .waveform:
            analysis.waveform = nil
            cacheValidity.removeValue(forKey: "waveform")
        case .peak:
            analysis.peak = nil
            cacheValidity.removeValue(forKey: "peak")
        case .keyframeIndex:
            analysis.keyframeIndex = nil
            cacheValidity.removeValue(forKey: "keyframeIndex")
        case .thumbnailIndex:
            analysis.thumbnailIndex = nil
            cacheValidity.removeValue(forKey: "thumbnailIndex")
        }
    }

    /// Clears all analysis.
    public func clearAllAnalysis() {
        analysis = AnalysisState()
        cacheValidity.removeAll()
    }

    // MARK: - Pending Tasks

    /// Marks an analysis as in progress.
    public func markTaskPending(_ type: AnalysisType) {
        pendingTasks.insert(type.rawValue)
    }

    /// Marks an analysis as complete.
    public func markTaskComplete(_ type: AnalysisType) {
        pendingTasks.remove(type.rawValue)
    }

    /// Whether an analysis task is pending.
    public func isTaskPending(_ type: AnalysisType) -> Bool {
        pendingTasks.contains(type.rawValue)
    }

    // MARK: - Annotations

    /// Current annotations.
    public var userAnnotations: UserAnnotations {
        annotations
    }

    /// Updates annotations.
    public func updateAnnotations(_ newAnnotations: UserAnnotations) {
        annotations = newAnnotations
    }

    /// Adds a tag.
    public func addTag(_ tag: String) {
        if !annotations.tags.contains(tag) {
            annotations.tags.append(tag)
        }
    }

    /// Removes a tag.
    public func removeTag(_ tag: String) {
        annotations.tags.removeAll { $0 == tag }
    }

    /// Sets a marker at a time.
    public func setMarker(at time: Double, label: String) {
        annotations.markers[time] = label
    }

    /// Removes a marker.
    public func removeMarker(at time: Double) {
        annotations.markers.removeValue(forKey: time)
    }

    /// Sets in/out points.
    public func setInOutPoints(inPoint: Double?, outPoint: Double?) {
        annotations.inPoint = inPoint
        annotations.outPoint = outPoint
    }

    /// Sets rating.
    public func setRating(_ rating: Int?) {
        annotations.rating = rating
    }

    /// Sets notes.
    public func setNotes(_ notes: String?) {
        annotations.notes = notes
    }

    // MARK: - Cache Validity

    /// Gets cache validity for an analysis type.
    public func getCacheValidity(for type: AnalysisType) -> CacheValidity? {
        cacheValidity[type.rawValue]
    }

    /// Whether a cache is valid (time-based only).
    ///
    /// For hash-based validation, use `isCacheValid(for:withSourceHash:)`.
    public func isCacheValid(for type: AnalysisType) -> Bool {
        guard let validity = cacheValidity[type.rawValue] else {
            return false
        }
        return validity.isValid
    }

    /// Whether a cache is valid, optionally using source hash comparison.
    ///
    /// When a current source hash is provided, hash comparison takes precedence
    /// over time-based expiration. This is useful for long-lived caches where
    /// the source file hasn't changed.
    ///
    /// - Parameters:
    ///   - type: The analysis type to check.
    ///   - currentHash: The current hash of the source file, if available.
    /// - Returns: True if the cache is valid.
    public func isCacheValid(for type: AnalysisType, withSourceHash currentHash: String?) -> Bool {
        guard let validity = cacheValidity[type.rawValue] else {
            return false
        }
        return validity.isValid(withCurrentHash: currentHash)
    }

    /// Whether a cache is valid and compatible with a required version.
    ///
    /// - Parameters:
    ///   - type: The analysis type to check.
    ///   - requiredVersion: The minimum required generator version.
    ///   - currentHash: Optional current source hash for hash-based validation.
    /// - Returns: True if the cache is valid and version-compatible.
    public func isCacheValidAndCompatible(
        for type: AnalysisType,
        requiredVersion: String,
        withSourceHash currentHash: String? = nil
    ) -> Bool {
        guard let validity = cacheValidity[type.rawValue] else {
            return false
        }
        guard validity.isCompatible(withVersion: requiredVersion) else {
            return false
        }
        return validity.isValid(withCurrentHash: currentHash)
    }

    // MARK: - Serialization

    /// Snapshot of the store for serialization.
    public struct Snapshot: Codable, Sendable {
        public let analysis: AnalysisState
        public let cacheValidity: [String: CacheValidity]
        public let annotations: UserAnnotations
    }

    /// Creates a snapshot of current state.
    public func snapshot() -> Snapshot {
        Snapshot(
            analysis: analysis,
            cacheValidity: cacheValidity,
            annotations: annotations
        )
    }

    /// Restores from a snapshot.
    public func restore(from snapshot: Snapshot) {
        self.analysis = snapshot.analysis
        self.cacheValidity = snapshot.cacheValidity
        self.annotations = snapshot.annotations
    }
}

// MARK: - Analysis Type

/// Types of analysis that can be performed.
public enum AnalysisType: String, CaseIterable, Sendable {
    case waveform
    case peak
    case keyframeIndex
    case thumbnailIndex
}
